---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: XSRF/CSRF-Verhinderung in ASP.NET MVC und Web Pages | Microsoft-Dokumentation
author: Rick-Anderson
description: Website übergreifende Anforderungs Fälschung (auch als XSRF oder CSRF bezeichnet) ist ein Angriff auf im Internet gehostete Anwendungen, bei denen eine böswillige Website den Zugriff auf die interacti beeinflussen kann...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455528"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="d2c1a-103">XSRF/CSRF-Schutz bei ASP.NET MVC und Web Pages</span><span class="sxs-lookup"><span data-stu-id="d2c1a-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="d2c1a-104">von [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="d2c1a-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="d2c1a-105">Die Website übergreifende Anforderungs Fälschung (auch als XSRF oder CSRF bezeichnet) ist ein Angriff auf im Internet gehostete Anwendungen, bei dem eine böswillige Website die Interaktion zwischen einem Client Browser und einer Website beeinflussen kann, die von diesem Browser als vertrauenswürdig eingestuft wird.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="d2c1a-106">Diese Angriffe können durchgeführt werden, da Webbrowser Authentifizierungs Token automatisch mit jeder Anforderung an eine Website senden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="d2c1a-107">Ein typisches Beispiel ist ein Authentifizierungscookie, wie das Authentifizierungsticket von ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="d2c1a-108">Allerdings können Websites, die einen permanenten Authentifizierungsmechanismus (z. b. Windows-Authentifizierung, Basic usw.) verwenden, diese Angriffe als Ziel verwenden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="d2c1a-109">Ein XSRF-Angriff unterscheidet sich von einem Phishing-Angriff.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="d2c1a-110">Bei Phishing-Angriffen ist die Beihilfe des Opfers erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="d2c1a-111">Bei einem Phishingangriff imitiert eine böswillige Website die Zielwebsite, und das Opfer wird getäuscht, um dem Angreifer vertrauliche Informationen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="d2c1a-112">Bei einem XSRF-Angriff ist häufig keinerlei Aktion des Opfers erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="d2c1a-113">Der Angreifer verlässt sich vielmehr darauf, dass der Browser automatisch alle relevanten Cookies an die Zielwebsite sendet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="d2c1a-114">Weitere Informationen finden Sie unter [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="d2c1a-115">Anatomie eines Angriffs</span><span class="sxs-lookup"><span data-stu-id="d2c1a-115">Anatomy of an attack</span></span>

<span data-ttu-id="d2c1a-116">Um einen XSRF-Angriff zu durchlaufen, sollten Sie einen Benutzer in Erwägung ziehen, der einige Online-Banking-Transaktionen ausführen möchte.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="d2c1a-117">Dieser Benutzer besucht zuerst woodgrovebank.com und meldet sich an. zu diesem Zeitpunkt enthält der Antwortheader das Authentifizierungs Cookie:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="d2c1a-118">Da das Authentifizierungs Cookie ein Sitzungs Cookie ist, wird es automatisch vom Browser gelöscht, wenn der Browser Prozess beendet wird.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="d2c1a-119">Bis zu diesem Zeitpunkt schließt der Browser das Cookie jedoch automatisch mit jeder Anforderung an woodgrovebank.com ein.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="d2c1a-120">Der Benutzer möchte nun $1000 an ein anderes Konto übertragen. daher füllt er ein Formular auf der Bank Website aus, und der Browser sendet diese Anforderung an den Server:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="d2c1a-121">Da dieser Vorgang einen Nebeneffekt hat (er initiiert eine monetäre Transaktion), hat die Bank Site eine HTTP POST-Anforderung angefordert, um diesen Vorgang zu initiieren.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="d2c1a-122">Der Server liest das Authentifizierungs Token aus der Anforderung, sucht nach der Kontonummer des aktuellen Benutzers, überprüft, ob genügend Geld vorhanden ist, und initiiert dann die Transaktion in das Zielkonto.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="d2c1a-123">Ihr Online-Banking ist fertig, der Benutzer navigiert von der Bank Website und besucht andere Orte im Web.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="d2c1a-124">Eine dieser Sites – fabrikam.com – enthält das folgende Markup auf einer Seite, die in einem &lt;IFRAME-&gt;eingebettet ist:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="d2c1a-125">Dies bewirkt, dass der Browser diese Anforderung vornimmt:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="d2c1a-126">Der Angreifer nutzt die Tatsache, dass der Benutzer möglicherweise noch über ein gültiges Authentifizierungs Token für die Zielwebsite verfügt, und verwendet einen kleinen Code Ausschnitt, damit der Browser automatisch eine HTTP POST-Anforderung an die Zielsite sendet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="d2c1a-127">Wenn das Authentifizierungs Token weiterhin gültig ist, initiiert die bankensite eine Übertragung von $250 in das Konto der Wahl des Angreifers.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="d2c1a-128">Ineffiziente entschärfungen</span><span class="sxs-lookup"><span data-stu-id="d2c1a-128">Ineffective mitigations</span></span>

<span data-ttu-id="d2c1a-129">Es ist interessant zu beachten, dass im obigen Szenario die Tatsache, dass woodgrovebank.com über SSL aufgerufen wurde und ein SSL-Authentifizierungs Cookie enthielt, nicht ausreichen konnte, um den Angriff zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="d2c1a-130">Der Angreifer kann das [URI-Schema](http://en.wikipedia.org/wiki/URI_scheme) (HTTPS) in ihrer &lt;Form&gt; Element angeben, und der Browser sendet weiterhin nicht abgelaufene Cookies an die Zielwebsite, solange diese Cookies mit dem URI-Schema des beabsichtigten Ziels konsistent sind.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="d2c1a-131">Man könnte argumentieren, dass der Benutzer einfach nicht vertrauenswürdige Sites besuchen sollte, da der Besuch nur vertrauenswürdiger Websites die Sicherheit online bleibt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="d2c1a-132">Es gibt eine wahre Wahrheit, aber leider ist dieser Ratgeber nicht immer praktikabel.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="d2c1a-133">Möglicherweise ist der Benutzer der lokalen News Site konsolidatedmessenger vertraut.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="d2c1a-134">ConsolidatedMessenger.com und besuchen Sie stattdessen diese Website, aber diese Site verfügt über ein XSS-Sicherheitsrisiko, mit dem ein Angreifer denselben Code Ausschnitt einfügen kann, der auf fabrikam.com ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="d2c1a-135">Sie können überprüfen, ob eingehende Anforderungen über einen [Referer-Header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) verfügen, der auf Ihre Domäne verweist.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="d2c1a-136">Dadurch werden Anforderungen, die von einer Drittanbieter Domäne übermittelt werden, nicht mehr unterbrochen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="d2c1a-137">Allerdings deaktivieren einige Benutzer den verweigerheader Ihres Browsers aus Datenschutzgründen, und Angreifer können diese Kopfzeile manchmal spoden, wenn das Opfer eine bestimmte unsichere Software installiert hat.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="d2c1a-138">Das Überprüfen des [verweigerheaders](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) wird nicht als sicherer Ansatz zum Verhindern von XSRF-Angriffen angesehen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="d2c1a-139">XSRF-entschärfungen für Web Stack-Laufzeit</span><span class="sxs-lookup"><span data-stu-id="d2c1a-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="d2c1a-140">Die ASP.net-webstack-Laufzeit verwendet eine Variante des [Synchronisierungs Token-Musters](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) , um gegen XSRF-Angriffe zu schützen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="d2c1a-141">Die allgemeine Form des Synchronisierungs Token-Musters besteht darin, dass zwei Anti-XSRF-Token an den Server übermittelt werden, wobei jede HTTP POST-Anforderung (zusätzlich zum Authentifizierungs Token) verwendet wird: ein Token als Cookie und das andere als Formular Wert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="d2c1a-142">Die von der ASP.NET-Laufzeit generierten Tokenwerte sind von einem Angreifer nicht deterministisch oder vorhersagbar.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="d2c1a-143">Wenn die Token übermittelt werden, lässt der Server zu, dass die Anforderung nur fortgesetzt werden kann, wenn beide Token eine Vergleichs Überprüfung bestehen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="d2c1a-144">Das *Sitzungs Token* für die XSRF-Anforderungs Überprüfung wird als HTTP-Cookie gespeichert und enthält derzeit die folgenden Informationen in der Nutzlast:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="d2c1a-145">Ein Sicherheits Token, das aus einem zufälligen 128-Bit-Bezeichner besteht.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="d2c1a-146">Die folgende Abbildung zeigt das Sitzungs Token für die XSRF-Anforderungs Überprüfung, das mit den Internet Explorer F12-Entwicklertools angezeigt wird: (Beachten Sie, dass es sich hierbei um die aktuelle Implementierung handelt, die sich wahrscheinlich ändern kann.)</span><span class="sxs-lookup"><span data-stu-id="d2c1a-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="d2c1a-147">Das *Feld Token* wird als `<input type="hidden" />` gespeichert und enthält die folgenden Informationen in seiner Nutzlast:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="d2c1a-148">Der Benutzername des angemeldeten Benutzers (falls authentifiziert).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="d2c1a-149">Alle zusätzlichen Daten, die von einem [iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="d2c1a-150">Die Nutzlasten der Anti-XSRF-Token werden verschlüsselt und signiert, sodass Sie den Benutzernamen nicht anzeigen können, wenn Sie Tools verwenden, um die Token zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="d2c1a-151">Wenn die Webanwendung auf ASP.NET 4,0 ausgerichtet ist, werden [Kryptografiedienste von der machineKey. Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) -Routine bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="d2c1a-152">Wenn die Webanwendung auf ASP.NET 4,5 oder höher ausgerichtet ist, werden [Kryptografiedienste von der machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) -Routine bereitgestellt, die eine bessere Leistung, Erweiterbarkeit und Sicherheit bietet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="d2c1a-153">Weitere Informationen finden Sie in den folgenden Blogbeiträgen:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="d2c1a-154">Kryptografische Verbesserungen in ASP.NET 4,5, PT. 1</span><span class="sxs-lookup"><span data-stu-id="d2c1a-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="d2c1a-155">Kryptografische Verbesserungen in ASP.NET 4,5, PT. 2</span><span class="sxs-lookup"><span data-stu-id="d2c1a-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="d2c1a-156">Kryptografische Verbesserungen in ASP.NET 4,5, PT. 3</span><span class="sxs-lookup"><span data-stu-id="d2c1a-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="d2c1a-157">Erstellen der Token</span><span class="sxs-lookup"><span data-stu-id="d2c1a-157">Generating the tokens</span></span>

<span data-ttu-id="d2c1a-158">Um die Anti-XSRF-Token zu generieren, rufen Sie die [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) -Methode aus einer MVC-Ansicht oder @AntiForgery.GetHtml() auf einer Razor Page auf.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="d2c1a-159">Die Laufzeit führt dann die folgenden Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="d2c1a-160">Wenn die aktuelle HTTP-Anforderung bereits ein Anti-XSRF-Sitzungs Token enthält (das Anti-XSRF-Cookie \_\_requestverificationtoken), wird das Sicherheits Token daraus extrahiert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="d2c1a-161">Wenn die HTTP-Anforderung kein Anti-XSRF-Sitzungs Token enthält oder wenn das Extrahieren des Sicherheits Tokens fehlschlägt, wird ein neues zufälliges Anti-XSRF-Token generiert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="d2c1a-162">Ein Anti-XSRF-Feldtoken wird mit dem Sicherheits Token aus Schritt (1) oben und der Identität des aktuell angemeldeten Benutzers generiert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="d2c1a-163">(Weitere Informationen zum Bestimmen der Benutzeridentität finden Sie unten im Abschnitt **[Szenarios mit besonderem Support](#_Scenarios_with_special)** .) Wenn außerdem ein [iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) konfiguriert ist, ruft die Laufzeit die [getadditionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) -Methode auf und schließt die zurückgegebene Zeichenfolge in das Feld Token ein.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="d2c1a-164">(Weitere Informationen finden Sie im Abschnitt **[Konfiguration und Erweiterbarkeit](#_Configuration_and_extensibility)** .)</span><span class="sxs-lookup"><span data-stu-id="d2c1a-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="d2c1a-165">Wenn ein neues Anti-XSRF-Token in Schritt (1) generiert wurde, wird ein neues Sitzungs Token erstellt, das es enthält und der ausgehenden HTTP-Cookies-Auflistung hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="d2c1a-166">Das Feld Token aus Schritt (2) wird in ein `<input type="hidden" />` Element umschließt, und dieses HTML-Markup ist der Rückgabewert von `Html.AntiForgeryToken()` oder `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="d2c1a-167">Validieren der Token</span><span class="sxs-lookup"><span data-stu-id="d2c1a-167">Validating the tokens</span></span>

<span data-ttu-id="d2c1a-168">Zum Überprüfen der eingehenden Anti-XSRF-Token enthält der Entwickler ein [validateantiforgerytoken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) -Attribut für die MVC-Aktion oder den MVC-Controller, oder er ruft `@AntiForgery.Validate()` von der Razor Page auf.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="d2c1a-169">Die Laufzeit führt die folgenden Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="d2c1a-170">Das eingehende Sitzungs Token und das Feld Token werden gelesen, und das Anti-XSRF-Token wird aus jedem extrahiert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="d2c1a-171">Die Anti-XSRF-Token müssen in der Generierungs Routine pro Schritt (2) identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="d2c1a-172">Wenn der aktuelle Benutzer authentifiziert ist, wird der Benutzername mit dem Benutzernamen verglichen, der im Feld Token gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="d2c1a-173">Die Benutzernamen müssen mit identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-173">The usernames must match.</span></span>
3. <span data-ttu-id="d2c1a-174">Wenn ein [iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) konfiguriert ist, ruft die Laufzeit die *validateadditionaldata* -Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="d2c1a-175">Die Methode muss den booleschen Wert " *true*" zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="d2c1a-176">Wenn die Überprüfung erfolgreich ist, kann die Anforderung fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="d2c1a-177">Wenn die Validierung fehlschlägt, löst das Framework eine *httpantiforgeryexception*aus.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="d2c1a-178">Fehlerbedingungen</span><span class="sxs-lookup"><span data-stu-id="d2c1a-178">Failure conditions</span></span>

<span data-ttu-id="d2c1a-179">Beginnend mit der ASP.net Web Stack-Laufzeit v2 enthalten alle *httpantiforgeryexception-Ausnahmen* , die während der Validierung ausgelöst werden, ausführliche Informationen über den Fehler.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="d2c1a-180">Die aktuell definierten Fehlerbedingungen sind:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="d2c1a-181">Das Sitzungs Token oder das Formular Token ist in der Anforderung nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="d2c1a-182">Das Sitzungs Token oder das Formular Token ist nicht lesbar.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="d2c1a-183">Die wahrscheinlichste Ursache hierfür ist eine Farm mit nicht übereinstimmenden Versionen der ASP.net-webstack-Laufzeit oder einer Farm, in der sich das &lt;machineKey-&gt; Element in Web. config zwischen den Computern unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="d2c1a-184">Sie können ein Tool wie z. b. "fddler" verwenden, um diese Ausnahme zu erzwingen, indem Sie entweder das Anti-XSRF-Token manipulieren.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="d2c1a-185">Das Sitzungs Token und das Feld Token wurden ausgetauscht.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="d2c1a-186">Das Sitzungs Token und das Feld Token enthalten nicht übereinstimmende Sicherheits Token.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="d2c1a-187">Der in das Feld Token eingebettete Benutzername stimmt nicht mit dem Benutzernamen des aktuell angemeldeten Benutzers ab.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="d2c1a-188">Die *[iantiforgeryadditionaldataprovider. validateadditionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* -Methode hat *false*zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="d2c1a-189">Die Anti-XSRF-Funktionen können auch während der tokengenerierung oder-Validierung zusätzliche Überprüfungen durchführen, und Fehler während dieser Überprüfungen können dazu führen, dass Ausnahmen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="d2c1a-190">Weitere Informationen finden Sie in den Abschnitten [WIF/ACS/Anspruchs basierte Authentifizierung](#_WIF_ACS) und **[Konfiguration und Erweiterbarkeit](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="d2c1a-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="d2c1a-191">Szenarios mit spezieller Unterstützung</span><span class="sxs-lookup"><span data-stu-id="d2c1a-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="d2c1a-192">Anonyme Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="d2c1a-192">Anonymous authentication</span></span>

<span data-ttu-id="d2c1a-193">Das Anti-XSRF-System enthält spezielle Unterstützung für anonyme Benutzer, wobei "Anonymous" als Benutzer definiert ist, in dem die *IIdentity. IsAuthenticated* -Eigenschaft " *false*" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="d2c1a-194">Zu den Szenarien gehören das Bereitstellen von XSRF-Schutz auf der Anmeldeseite (vor der Authentifizierung des Benutzers) und benutzerdefinierte Authentifizierungs Schemas, in denen die Anwendung einen anderen Mechanismus als *IIdentity* zum Identifizieren von Benutzern verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="d2c1a-195">Um diese Szenarien zu unterstützen, erinnern Sie sich, dass die Sitzungs-und Feld Token durch ein Sicherheits Token verknüpft werden, bei dem es sich um einen zufällig generierten 128-Bit-Bezeichner handelt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="d2c1a-196">Dieses Sicherheits Token wird verwendet, um die Sitzung eines einzelnen Benutzers zu verfolgen, während Sie die Website navigiert, sodass es praktisch den Zweck eines anonymen Bezeichners erfüllt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="d2c1a-197">Anstelle des Benutzernamens für die oben beschriebenen Generierungs-und Validierungs Routinen wird eine leere Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="d2c1a-198">WIF/ACS/Anspruchs basierte Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="d2c1a-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="d2c1a-199">Normalerweise verfügen die in den .NET Framework integrierten *IIdentity* -Klassen über die Eigenschaft, mit der *IIdentity.Name* einen bestimmten Benutzer innerhalb einer bestimmten Anwendung eindeutig identifizieren kann.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="d2c1a-200">Beispielsweise gibt *FormsIdentity.Name* den in der Mitgliedschafts Datenbank gespeicherten Benutzernamen zurück (der für alle Anwendungen in Abhängigkeit von der Datenbank eindeutig ist), *WindowsIdentity.Name* gibt die Domänen qualifizierte Identität des Benutzers zurück usw.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="d2c1a-201">Diese Systeme bieten nicht nur die Authentifizierung, sondern Außerdem *identifizieren* Sie Benutzer für eine Anwendung.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="d2c1a-202">Bei der Anspruchs basierten Authentifizierung ist hingegen nicht unbedingt die Identifizierung eines bestimmten Benutzers erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="d2c1a-203">Stattdessen sind die Typen " *ClaimsPrincipal* " und " *ClaimsIdentity* " mit einem Satz von *Anspruchs* Instanzen verknüpft, wobei die einzelnen Ansprüche "ist 18 + Jahre des Alters" oder "ist ein Administrator".</span><span class="sxs-lookup"><span data-stu-id="d2c1a-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="d2c1a-204">Da der Benutzer nicht unbedingt identifiziert wurde, kann die Common Language Runtime die *ClaimsIdentity.Name* -Eigenschaft nicht als eindeutigen Bezeichner für diesen bestimmten Benutzer verwenden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="d2c1a-205">Das Team hat praktische Beispiele gesehen, in denen *ClaimsIdentity.Name* *null*zurückgibt, einen anzeigen Amen zurückgibt oder andernfalls eine Zeichenfolge zurückgibt, die nicht für die Verwendung als eindeutiger Bezeichner für den Benutzer geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="d2c1a-206">Viele bereit Stellungen, die die Anspruchs basierte Authentifizierung verwenden, verwenden insbesondere [Azure-Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="d2c1a-207">ACS ermöglicht es dem Entwickler, individuelle *Identitäts Anbieter* (z. b. AD FS, den Microsoft-Konto Anbieter, OpenID-Anbieter wie Yahoo! usw.) zu konfigurieren, und die Identitäts Anbieter geben *namens*Bezeichner zurück.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="d2c1a-208">Diese namens Bezeichner können personenbezogene Informationen (PII) wie eine e-Mail-Adresse enthalten, oder Sie können anonymisiert werden, wie eine private persönliche ID (PPID).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="d2c1a-209">Unabhängig davon, dass das Tupel (Identitäts Anbieter, namens Bezeichner) ausreichend als ein geeignetes Überwachungs Token für einen bestimmten Benutzer fungiert, während Sie die Website durchsucht, kann die ASP.net Web Stack-Laufzeit das Tupel anstelle des Benutzernamens verwenden, wenn Sie erstellen. die Anti-XSRF-Feldtoken werden überprüft.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="d2c1a-210">Die spezifischen URIs für den Identitäts Anbieter und den namens Bezeichner lauten:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="d2c1a-211">(Weitere Informationen finden Sie auf dieser [ACS-Dokumentseite](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) .)</span><span class="sxs-lookup"><span data-stu-id="d2c1a-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="d2c1a-212">Beim Erstellen oder Validieren eines Tokens versucht die ASP.net Web Stack-Laufzeit, eine Bindung an die Typen zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="d2c1a-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (für das WIF-SDK)</span><span class="sxs-lookup"><span data-stu-id="d2c1a-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="d2c1a-214">`System.Security.Claims.ClaimsIdentity` (für .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="d2c1a-215">Wenn diese Typen vorhanden sind und die *iiiidentity* des aktuellen Benutzers einen dieser Typen implementiert oder Unterklassen implementiert, verwendet die Anti-XSRF-Funktion beim erzeugen und Überprüfen der Token das Tupel (Identity Provider, Name Identifier) anstelle des Benutzernamens.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="d2c1a-216">Wenn kein Tupel vorhanden ist, schlägt die Anforderung fehl, und es wird ein Fehler angezeigt, der den Entwicklern beschreibt, wie das Anti-XSRF-System konfiguriert werden soll, um den spezifischen Anspruchs basierten Authentifizierungsmechanismus zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="d2c1a-217">Weitere Informationen finden Sie im Abschnitt **[Konfiguration und Erweiterbarkeit](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="d2c1a-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="d2c1a-218">OAuth-/OpenID-Authentifizierung</span><span class="sxs-lookup"><span data-stu-id="d2c1a-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="d2c1a-219">Schließlich verfügt die Anti-XSRF-Funktion über besondere Unterstützung für Anwendungen, die OAuth oder OpenID-Authentifizierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="d2c1a-220">Diese Unterstützung ist heuristisch-basiert: Wenn die aktuelle *IIdentity.Name* mit http://oder https://beginnt, werden Benutzernamen Vergleiche mithilfe eines ordinalen Vergleichs anstelle des Standard Vergleichs der OrdinalIgnoreCase durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="d2c1a-221">Konfiguration und Erweiterbarkeit</span><span class="sxs-lookup"><span data-stu-id="d2c1a-221">Configuration and extensibility</span></span>

<span data-ttu-id="d2c1a-222">Gelegentlich benötigen Entwickler eine strengere Kontrolle über das Anti-XSRF-Generierungs-und Validierungs Verhalten.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="d2c1a-223">Beispielsweise ist das Standardverhalten von MVC-und Web Pages-Hilfsprogrammen zum automatischen Hinzufügen von HTTP-Cookies zur Antwort nicht erwünscht, und der Entwickler möchte die Token an anderer Stelle aufbewahren.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="d2c1a-224">Hierfür gibt es zwei APIs:</span><span class="sxs-lookup"><span data-stu-id="d2c1a-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="d2c1a-225">Die *getTokens* -Methode übernimmt als Eingabe ein vorhandenes XSRF-Anforderungs Überprüfungs-Sitzungs Token (das möglicherweise NULL ist) und erzeugt als Ausgabe ein neues Sitzungs Token für die XSRF-Anforderungs Überprüfung und ein Feld Token.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="d2c1a-226">Die Token sind einfach nicht transparente Zeichen folgen ohne Dekoration. der *formtoken* -Wert wird beispielsweise nicht in eine &lt;Eingabe&gt; Tag umschließt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="d2c1a-227">Der *newcookietoken* -Wert kann NULL sein. Wenn dies der Fall ist, ist der Wert *oldcookietoken* weiterhin gültig, und es muss kein neues Antwort Cookie festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="d2c1a-228">Der Aufrufer von *getTokens* ist dafür verantwortlich, alle notwendigen Antwort Cookies beizubehalten oder das erforderliche Markup zu erzeugen. die *getTokens* -Methode selbst ändert die Antwort nicht als Nebeneffekt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="d2c1a-229">Die *Validate* -Methode nimmt die eingehenden Sitzungs-und Feld Token an und führt die oben genannte Validierungs Logik aus.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="d2c1a-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="d2c1a-230">AntiForgeryConfig</span></span>

<span data-ttu-id="d2c1a-231">Der Entwickler kann das Anti-XSRF-System vom Anwendungs\_aus konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="d2c1a-232">Die Konfiguration ist Programm gesteuert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-232">Configuration is programmatic.</span></span> <span data-ttu-id="d2c1a-233">Die Eigenschaften des statischen *antiforgeryconfig* -Typs werden unten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="d2c1a-234">Die meisten Benutzer, die Ansprüche verwenden, möchten die uniqueclaimtypeidentifier-Eigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="d2c1a-235">**Eigenschaft**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-235">**Property**</span></span> | <span data-ttu-id="d2c1a-236">**Beschreibung**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="d2c1a-237">**Additionaldataprovider**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="d2c1a-238">Ein [iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , der während der tokengenerierung zusätzliche Daten bereitstellt und während der tokenüberprüfung zusätzliche Daten verbraucht.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="d2c1a-239">Der Standardwert ist *NULL*.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-239">The default value is *null*.</span></span> <span data-ttu-id="d2c1a-240">Weitere Informationen finden Sie im Abschnitt [iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="d2c1a-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="d2c1a-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-241">**CookieName**</span></span> | <span data-ttu-id="d2c1a-242">Eine Zeichenfolge, die den Namen des HTTP-Cookies bereitstellt, das verwendet wird, um das Anti-XSRF-Sitzungs Token zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="d2c1a-243">Wenn dieser Wert nicht festgelegt ist, wird basierend auf dem bereitgestellten virtuellen Pfad der Anwendung automatisch ein Name generiert.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="d2c1a-244">Der Standardwert ist *NULL*.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-244">The default value is *null*.</span></span> |
| <span data-ttu-id="d2c1a-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-245">**RequireSsl**</span></span> | <span data-ttu-id="d2c1a-246">Ein boolescher Wert, der festlegt, ob die Anti-XSRF-Token über einen SSL-gesicherten Kanal übermittelt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="d2c1a-247">Wenn dieser Wert *true*ist, wird für alle automatisch generierten Cookies das Flag "Secure" festgelegt, und die Anti-XSRF-APIs lösen Sie aus, wenn Sie aus einer Anforderung aufgerufen werden, die nicht über SSL übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="d2c1a-248">Der Standardwert ist *false*.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-248">The default value is *false*.</span></span> |
| <span data-ttu-id="d2c1a-249">**Suppressidentityheuristicchecks**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="d2c1a-250">Ein boolescher Wert, der festlegt, ob das Anti-XSRF-System seine Unterstützung für Anspruchs basierte Identitäten deaktivieren soll.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="d2c1a-251">Wenn dieser Wert *true*ist, geht das System davon aus, dass *IIdentity.Name* für die Verwendung als eindeutiger Benutzer spezifischer Bezeichner geeignet ist, und versucht nicht, wie im Abschnitt " [WIF/ACS/Anspruchs basierte Authentifizierung](#_WIF_ACS) " beschrieben eine sonderschreibung für " *IClaimsIdentity* " oder " *clclaimsidentity* " zu finden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="d2c1a-252">Standardwert: `false`.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-252">The default value is `false`.</span></span> |
| <span data-ttu-id="d2c1a-253">**Uniqueclaimtypeidentifier**</span><span class="sxs-lookup"><span data-stu-id="d2c1a-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="d2c1a-254">Eine Zeichenfolge, die angibt, welcher Anspruchstyp für die Verwendung als eindeutiger Bezeichner pro Benutzer geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="d2c1a-255">Wenn dieser Wert festgelegt wird und die aktuelle *IIdentity* Anspruchs basiert ist, versucht das System, einen Anspruch des Typs zu extrahieren, der von *uniqueclaimtypeidentifier*festgelegt wurde, und der entsprechende Wert wird anstelle des Benutzernamens des Benutzers verwendet, wenn das Feld Token erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="d2c1a-256">Wenn der Anspruchstyp nicht gefunden wird, wird die Anforderung vom System nicht bestanden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="d2c1a-257">Der Standardwert ist *null*. Dies bedeutet, dass das System das Tupel (Identitäts Anbieter, namens Bezeichner) wie zuvor beschrieben anstelle des Benutzernamens des Benutzers verwenden soll.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="d2c1a-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="d2c1a-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="d2c1a-259">Der *[iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* -Typ ermöglicht es Entwicklern, das Verhalten des Anti-XSRF-Systems zu erweitern, indem zusätzliche Daten in jedem Token abgerundet werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="d2c1a-260">Die *getadditionaldata* -Methode wird jedes Mal aufgerufen, wenn ein Feld Token generiert wird, und der Rückgabewert wird in das generierte Token eingebettet.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="d2c1a-261">Ein Implementierer könnte einen Zeitstempel, eine Nonce oder einen beliebigen anderen Wert zurückgeben, den Sie von dieser Methode wünscht.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="d2c1a-262">Entsprechend wird die *validateadditionaldata* -Methode jedes Mal aufgerufen, wenn ein Feld Token überprüft wird, und die "zusätzliche Daten"-Zeichenfolge, die in das Token eingebettet wurde, wird an die-Methode weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="d2c1a-263">Die Validierungs Routine kann ein Timeout implementieren (durch Überprüfen der aktuellen Zeit mit dem Zeitpunkt, an dem das Token erstellt wurde), eine Nonce-Überprüfungs Routine oder eine beliebige andere gewünschte Logik.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="d2c1a-264">Entwurfsentscheidungen und Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="d2c1a-264">Design decisions and security considerations</span></span>

<span data-ttu-id="d2c1a-265">Das Sicherheits Token, das die Sitzungs-und Feld Token verknüpft, ist technisch nur erforderlich, wenn Sie versuchen, anonyme/nicht authentifizierte Benutzer vor XSRF-Angriffen zu schützen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="d2c1a-266">Wenn der Benutzer authentifiziert ist, kann das Authentifizierungs Token selbst (vermutlich in Form eines Cookies gesendet) als eine Hälfte eines Synchronisierungs Token-Paars verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="d2c1a-267">Es gibt jedoch gültige Szenarios für den Schutz von Anmelde Seiten, die von nicht authentifizierten Benutzern betroffen sind, und die Anti-XSRF-Logik wurde vereinfacht, indem das Sicherheits Token stets erstellt und überprüft wurde, auch für authentifizierte Benutzer.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="d2c1a-268">Außerdem bietet es zusätzlichen Schutz für den Fall, dass ein Feld Token jemals von einem Angreifer kompromittiert wird. das Festlegen oder erraten des Sitzungs Tokens wäre eine andere Hürde, die der Angreifer überwinden könnte.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="d2c1a-269">Entwickler sollten Vorsicht walten lassen, wenn mehrere Anwendungen in einer einzelnen Domäne gehostet werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="d2c1a-270">Obwohl es sich bei *example1.cloudapp.net* und *example2.cloudapp.net* um unterschiedliche Hosts handelt, besteht beispielsweise eine implizite Vertrauensstellung zwischen allen Hosts in der *\*. cloudapp.net* -Domäne.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="d2c1a-271">Diese implizite Vertrauensstellung [ermöglicht möglicherweise nicht vertrauenswürdigen Hosts, sich gegenseitig zu beeinflussen](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (die gleichen Ursprungs Richtlinien, die AJAX-Anforderungen Regeln, werden nicht notwendigerweise auf http-Cookies angewendet).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="d2c1a-272">Die ASP.net-webstack-Laufzeit stellt eine gewisse Entschärfung dar, da der Benutzername in das Feld Token eingebettet ist, sodass auch dann, wenn eine böswillige Unterdomäne ein Sitzungs Token überschreiben kann, kein gültiges Feld Token für den Benutzer generiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="d2c1a-273">Beim Hosten in einer solchen Umgebung können die integrierten Anti-XSRF-Routinen jedoch immer noch nicht gegen Session Hijacking oder Login-XSRF schützen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="d2c1a-274">Die Anti-XSRF-Routinen haben derzeit keine Schutz vor [Clickjacking](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="d2c1a-275">Anwendungen, die sich gegen Clickjacking schützen möchten, können dies problemlos erreichen, indem Sie einen X-Frame-Options: sameorigin-Header mit jeder Antwort senden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="d2c1a-276">Dieser Header wird von allen neueren Browsern unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="d2c1a-277">Weitere Informationen finden Sie im [IE-Blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), im [SDL-Blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)und im [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="d2c1a-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="d2c1a-278">Die ASP.net-Web Stack-Laufzeit kann in einer zukünftigen Version die MVC-und Web Pages-Anti-XSRF-Hilfsprogramme automatisch festlegen, sodass Anwendungen automatisch gegen diesen Angriff geschützt werden.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="d2c1a-279">Webentwickler sollten weiterhin sicherstellen, dass Ihre Website nicht anfällig für XSS-Angriffe ist.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="d2c1a-280">XSS-Angriffe sind sehr leistungsstark, und eine erfolgreiche Ausnutzung würde auch die ASP.net-Web Stack-Lauf Zeit Verteidigung gegen XSRF-Angriffe unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="d2c1a-281">Bestätigung</span><span class="sxs-lookup"><span data-stu-id="d2c1a-281">Acknowledgment</span></span>

<span data-ttu-id="d2c1a-282">[@LeviBroderick](https://twitter.com/LeviBroderick), die einen Großteil der ASP.net-Sicherheitscodes geschrieben hat, den Großteil dieser Informationen.</span><span class="sxs-lookup"><span data-stu-id="d2c1a-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
