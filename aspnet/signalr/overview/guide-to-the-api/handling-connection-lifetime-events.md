---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Verstehen und behandeln von Verbindungs Lebensdauer-Ereignissen in signalr | Microsoft-Dokumentation
author: bradygaster
description: In diesem Artikel wird beschrieben, wie die von der Hubs-API verfügbar gemachten Ereignisse verwendet werden.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/06/2020
ms.locfileid: "78467421"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="4af18-103">Überblick und Behandeln von Ereignissen im Zusammenhang mit der Verbindungslebensdauer in SignalR</span><span class="sxs-lookup"><span data-stu-id="4af18-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="4af18-104">Dieser Artikel bietet eine Übersicht über die signalr-Verbindung, die Verbindung wiederherstellen und Verbindungs Ereignisse, die Sie behandeln können, sowie über Timeout-und KeepAlive-Einstellungen, die Sie konfigurieren können.</span><span class="sxs-lookup"><span data-stu-id="4af18-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="4af18-105">In diesem Artikel wird davon ausgegangen, dass Sie bereits über Kenntnisse zu signalr und Verbindungs Lebensdauer-Ereignissen verfügen.</span><span class="sxs-lookup"><span data-stu-id="4af18-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="4af18-106">Eine Einführung in signalr finden Sie unter [Introduction to signalr (Einführung in signalr](../getting-started/introduction-to-signalr.md)).</span><span class="sxs-lookup"><span data-stu-id="4af18-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="4af18-107">Listen der Verbindungs Lebensdauer-Ereignisse finden Sie in den folgenden Ressourcen:</span><span class="sxs-lookup"><span data-stu-id="4af18-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="4af18-108">Behandeln von Verbindungs Lebensdauer-Ereignissen in der Hub-Klasse</span><span class="sxs-lookup"><span data-stu-id="4af18-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="4af18-109">Behandeln von Verbindungs Lebensdauer-Ereignissen in JavaScript-Clients</span><span class="sxs-lookup"><span data-stu-id="4af18-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="4af18-110">Behandeln von Verbindungs Lebensdauer-Ereignissen in .NET-Clients</span><span class="sxs-lookup"><span data-stu-id="4af18-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="4af18-111">In diesem Thema verwendete Software Versionen</span><span class="sxs-lookup"><span data-stu-id="4af18-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="4af18-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="4af18-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="4af18-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="4af18-113">.NET 4.5</span></span>
> - <span data-ttu-id="4af18-114">Signalr Version 2</span><span class="sxs-lookup"><span data-stu-id="4af18-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="4af18-115">Vorherige Versionen dieses Themas</span><span class="sxs-lookup"><span data-stu-id="4af18-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="4af18-116">Informationen zu früheren Versionen von signalr finden Sie unter [signalr ältere Versionen](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="4af18-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="4af18-117">Fragen und Kommentare</span><span class="sxs-lookup"><span data-stu-id="4af18-117">Questions and comments</span></span>
>
> <span data-ttu-id="4af18-118">Bitte informieren Sie sich darüber, wie Ihnen dieses Tutorial gefallen hat und was wir in den Kommentaren unten auf der Seite verbessern konnten.</span><span class="sxs-lookup"><span data-stu-id="4af18-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="4af18-119">Wenn Sie Fragen haben, die nicht direkt mit dem Tutorial zusammenhängen, können Sie Sie im [ASP.net signalr-Forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) oder in [StackOverflow.com](http://stackoverflow.com/)veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="4af18-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="4af18-120">Übersicht</span><span class="sxs-lookup"><span data-stu-id="4af18-120">Overview</span></span>

<span data-ttu-id="4af18-121">Dieser Artikel enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="4af18-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="4af18-122">Terminologie und Szenarien für die Verbindungs Lebensdauer</span><span class="sxs-lookup"><span data-stu-id="4af18-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="4af18-123">Signalr-Verbindungen, Transportverbindungen und physische Verbindungen</span><span class="sxs-lookup"><span data-stu-id="4af18-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="4af18-124">Übertragungs Szenarien für Transport Unterbrechung</span><span class="sxs-lookup"><span data-stu-id="4af18-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="4af18-125">Szenarios zur Trennung von Clients</span><span class="sxs-lookup"><span data-stu-id="4af18-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="4af18-126">Szenarios zur Server Trennung</span><span class="sxs-lookup"><span data-stu-id="4af18-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="4af18-127">Timeout-und KeepAlive-Einstellungen</span><span class="sxs-lookup"><span data-stu-id="4af18-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="4af18-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="4af18-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="4af18-129">"Disconnecttimeout"</span><span class="sxs-lookup"><span data-stu-id="4af18-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="4af18-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="4af18-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="4af18-131">Ändern der Timeout-und KeepAlive-Einstellungen</span><span class="sxs-lookup"><span data-stu-id="4af18-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="4af18-132">Benachrichtigen des Benutzers über Trennungen</span><span class="sxs-lookup"><span data-stu-id="4af18-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="4af18-133">Fortlaufende Wiederherstellung der Verbindung</span><span class="sxs-lookup"><span data-stu-id="4af18-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="4af18-134">Trennen einer Verbindung zwischen einem Client und Servercode</span><span class="sxs-lookup"><span data-stu-id="4af18-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="4af18-135">Erkennen der Ursache für eine Verbindungs Trennung</span><span class="sxs-lookup"><span data-stu-id="4af18-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="4af18-136">Links zu API-Referenz Themen beziehen sich auf die .NET 4,5-Version der API.</span><span class="sxs-lookup"><span data-stu-id="4af18-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="4af18-137">Wenn Sie .NET 4 verwenden, finden Sie weitere Informationen unter [.NET 4-Version der API-Themen](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="4af18-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="4af18-138">Terminologie und Szenarien für die Verbindungs Lebensdauer</span><span class="sxs-lookup"><span data-stu-id="4af18-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="4af18-139">Der `OnReconnected`-Ereignishandler in einem signalr-Hub kann direkt nach `OnConnected` ausgeführt werden, aber nicht nach `OnDisconnected` für einen bestimmten Client.</span><span class="sxs-lookup"><span data-stu-id="4af18-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="4af18-140">Der Grund, warum Sie eine erneute Verbindung ohne eine Verbindung herstellen können, besteht darin, dass es verschiedene Möglichkeiten gibt, wie das Wort "Connection" in signalr verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="4af18-141">Signalr-Verbindungen, Transportverbindungen und physische Verbindungen</span><span class="sxs-lookup"><span data-stu-id="4af18-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="4af18-142">In diesem Artikel wird zwischen *signalr-Verbindungen*, *Transportverbindungen*und *physischen Verbindungen*unterschieden:</span><span class="sxs-lookup"><span data-stu-id="4af18-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="4af18-143">Die **signalr-Verbindung** bezieht sich auf eine logische Beziehung zwischen einem Client und einer Server-URL, die von der signalr-API verwaltet und durch eine Verbindungs-ID eindeutig identifiziert wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="4af18-144">Die Daten über diese Beziehung werden von signalr verwaltet und zum Herstellen einer Transport Verbindung verwendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="4af18-145">Die Beziehung wird beendet, und signalr gibt die Daten frei, wenn der Client die `Stop` Methode aufruft, oder ein Timeout Limit erreicht wird, während signalr versucht, eine verlorene Transport Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="4af18-146">**Transport Verbindung** bezieht sich auf eine logische Beziehung zwischen einem Client und einem Server, der von einer der vier Transport-APIs verwaltet wird: websockets, vom Server gesendete Ereignisse, der dauerhafte Frame oder das lange abrufen.</span><span class="sxs-lookup"><span data-stu-id="4af18-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="4af18-147">Signalr verwendet die Transport-API, um eine Transport Verbindung herzustellen, und die Transport-API hängt davon ab, ob eine physische Netzwerkverbindung vorhanden ist, um die Transport Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="4af18-148">Die Transport Verbindung wird beendet, wenn signalr Sie beendet oder wenn die Transport-API erkennt, dass die physische Verbindung getrennt ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="4af18-149">Die **physische Verbindung** bezieht sich auf die physischen Netzwerkverbindungen--Drähte, drahtlos Signale, Router usw., die die Kommunikation zwischen einem Client Computer und einem Server Computer vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="4af18-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="4af18-150">Die physische Verbindung muss vorhanden sein, um eine Transport Verbindung herzustellen, und es muss eine Transport Verbindung hergestellt werden, um eine signalr-Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="4af18-151">Das Abbrechen der physischen Verbindung beendet jedoch nicht immer sofort die Transport Verbindung oder die signalr-Verbindung, wie weiter unten in diesem Thema erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="4af18-152">Im folgenden Diagramm wird die signalr-Verbindung durch die Hubs-API und die persistentconnection-API signalr-Schicht dargestellt. die Transport Verbindung wird von der Transportschicht dargestellt, und die physische Verbindung wird durch die Linien zwischen dem Server dargestellt. und die Clients.</span><span class="sxs-lookup"><span data-stu-id="4af18-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Signalr-Architektur Diagramm](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="4af18-154">Wenn Sie die `Start`-Methode in einem signalr-Client aufzurufen, stellen Sie dem signalr-Client Code alle Informationen bereit, die er benötigt, um eine physische Verbindung mit einem Server herzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="4af18-155">Der signalr-Client Code verwendet diese Informationen, um eine HTTP-Anforderung zu erstellen und eine physische Verbindung herzustellen, die eine der vier Transportmethoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="4af18-156">Wenn die Transport Verbindung fehlschlägt oder der Server ausfällt, wird die signalr-Verbindung nicht sofort entfernt, da der Client weiterhin über die Informationen verfügt, die er benötigt, um automatisch eine neue Transport Verbindung mit derselben signalr-URL wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="4af18-157">In diesem Szenario ist kein Eingreifen der Benutzeranwendung beteiligt, und wenn der signalr-Client Code eine neue Transport Verbindung herstellt, wird keine neue signalr-Verbindung gestartet.</span><span class="sxs-lookup"><span data-stu-id="4af18-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="4af18-158">Die Kontinuität der signalr-Verbindung wird in der Tatsache widergespiegelt, dass sich die Verbindungs-ID, die beim aufruft der `Start`-Methode erstellt wird, nicht ändert.</span><span class="sxs-lookup"><span data-stu-id="4af18-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="4af18-159">Der `OnReconnected`-Ereignishandler auf dem Hub wird ausgeführt, wenn eine Transport Verbindung nach dem Verlust der Verbindung automatisch wieder hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="4af18-160">Der `OnDisconnected`-Ereignishandler wird am Ende einer signalr-Verbindung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4af18-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="4af18-161">Eine signalr-Verbindung kann auf eine der folgenden Arten enden:</span><span class="sxs-lookup"><span data-stu-id="4af18-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="4af18-162">Wenn der Client die `Stop`-Methode aufruft, wird eine Nachricht zum Beenden an den Server gesendet, und sowohl der Client als auch der Server beenden die signalr-Verbindung sofort.</span><span class="sxs-lookup"><span data-stu-id="4af18-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="4af18-163">Nachdem die Konnektivität zwischen Client und Server verloren gegangen ist, versucht der Client, die Verbindung wiederherzustellen, und der Server wartet darauf, dass der Client erneut eine Verbindung herstellt.</span><span class="sxs-lookup"><span data-stu-id="4af18-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="4af18-164">Wenn die Versuche, die Verbindung wiederherzustellen, nicht erfolgreich sind und das Timeout für die Trennung endet, beenden sowohl der Client als auch der Server die signalr-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="4af18-165">Der Client versucht nicht mehr, die Verbindung wiederherzustellen, und der Server verwirft seine Darstellung der signalr-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="4af18-166">Wenn der Client nicht mehr ausgeführt werden kann, ohne dass die Möglichkeit besteht, die `Stop`-Methode aufzurufen, wartet der Server, bis der Client erneut eine Verbindung herstellt, und beendet dann die signalr-Verbindung nach dem Timeout Zeitraum für die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="4af18-167">Wenn der Server nicht mehr ausgeführt wird, versucht der Client, die Verbindung wiederherzustellen (die Transport Verbindung neu zu erstellen), und beendet dann die signalr-Verbindung nach dem Timeout Zeitraum für die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="4af18-168">Wenn keine Verbindungsprobleme vorliegen und die Benutzeranwendung die signalr-Verbindung beendet, indem Sie die `Stop`-Methode aufrufen, wird die signalr-Verbindung und die Transport Verbindung zum gleichen Zeitpunkt gestartet und beendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="4af18-169">In den folgenden Abschnitten werden die anderen Szenarien ausführlicher beschrieben.</span><span class="sxs-lookup"><span data-stu-id="4af18-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="4af18-170">Übertragungs Szenarien für Transport Unterbrechung</span><span class="sxs-lookup"><span data-stu-id="4af18-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="4af18-171">Physische Verbindungen können langsam sein, oder es können Unterbrechungen bei der Konnektivität auftreten.</span><span class="sxs-lookup"><span data-stu-id="4af18-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="4af18-172">Abhängig von Faktoren wie z. b. der Länge der Unterbrechung, wird die Transport Verbindung möglicherweise verworfen.</span><span class="sxs-lookup"><span data-stu-id="4af18-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="4af18-173">Signalr versucht dann, die Transport Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="4af18-174">Manchmal erkennt die Transport Verbindungs-API die Unterbrechung und löscht die Transport Verbindung. signalr findet sofort heraus, dass die Verbindung verloren geht.</span><span class="sxs-lookup"><span data-stu-id="4af18-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="4af18-175">In anderen Szenarien wird weder die Transport Verbindungs-API noch signalr sofort darauf hingewiesen, dass die Konnektivität verloren gegangen ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="4af18-176">Für alle Transporte außer Long-Abruf verwendet der signalr-Client eine Funktion mit dem Namen *KeepAlive* , um den Verlust der Konnektivität zu überprüfen, die von der Transport-API nicht erkannt werden kann.</span><span class="sxs-lookup"><span data-stu-id="4af18-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="4af18-177">Weitere Informationen zu langen Abruf Verbindungen finden Sie unter [Timeout-und KeepAlive-Einstellungen](#timeoutkeepalive) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="4af18-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="4af18-178">Wenn eine Verbindung inaktiv ist, sendet der Server in regelmäßigen Abständen ein KeepAlive-Paket an den Client.</span><span class="sxs-lookup"><span data-stu-id="4af18-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="4af18-179">Ab dem Zeitpunkt, an dem dieser Artikel geschrieben wurde, beträgt die Standard Häufigkeit alle 10 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="4af18-180">Wenn Sie diese Pakete überwachen, können Clients erkennen, ob ein Verbindungsproblem vorliegt.</span><span class="sxs-lookup"><span data-stu-id="4af18-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="4af18-181">Wenn ein KeepAlive-Paket nicht erwartungsgemäß empfangen wird, geht der Client nach kurzer Zeit davon aus, dass Verbindungsprobleme vorliegen, z. b. verlangsamtheit oder Unterbrechungen.</span><span class="sxs-lookup"><span data-stu-id="4af18-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="4af18-182">Wenn KeepAlive nach längerer Zeit immer noch nicht empfangen wird, nimmt der Client an, dass die Verbindung getrennt wurde, und versucht, erneut eine Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="4af18-183">Das folgende Diagramm veranschaulicht die Client-und Server Ereignisse, die in einem typischen Szenario ausgelöst werden, wenn Probleme mit der physischen Verbindung auftreten, die von der Transport-API nicht sofort erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="4af18-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="4af18-184">Das Diagramm gilt für die folgenden Umstände:</span><span class="sxs-lookup"><span data-stu-id="4af18-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="4af18-185">Der Transport ist ein websockets, ein unbenes Frame oder Ereignisse, die vom Server gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="4af18-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="4af18-186">Es gibt unterschiedliche Zeiträume der Unterbrechung der physischen Netzwerkverbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="4af18-187">Die Transport-API erkennt die Unterbrechungen nicht, sodass signalr die KeepAlive-Funktionalität verwendet, um Sie zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="4af18-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Transport Trennungen](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="4af18-189">Wenn der Client in den Modus zum erneuten Herstellen der Verbindung wechselt, aber keine Transport Verbindung innerhalb des Limits für den Trennungs Timeout herstellen kann, beendet der Server die signalr-Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="4af18-190">Wenn dies der Fall ist, führt der Server die `OnDisconnected` Methode des Hubs aus und fügt eine Disconnect-Nachricht in eine Warteschlange ein, die an den Client gesendet wird, wenn der Client eine spätere Verbindung herstellt.</span><span class="sxs-lookup"><span data-stu-id="4af18-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="4af18-191">Wenn der Client dann erneut eine Verbindung herstellt, empfängt er den Disconnect-Befehl und ruft die `Stop`-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="4af18-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="4af18-192">In diesem Szenario wird `OnReconnected` nicht ausgeführt, wenn der Client erneut eine Verbindung herstellt, und `OnDisconnected` wird nicht ausgeführt, wenn der Client `Stop`aufruft.</span><span class="sxs-lookup"><span data-stu-id="4af18-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="4af18-193">Dieses Szenario wird im folgenden Diagramm veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4af18-193">The following diagram illustrates this scenario.</span></span>

![Transport Unterbrechungen-Server Timeout](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="4af18-195">Die signalr-Verbindungs Lebensdauer Ereignisse, die möglicherweise auf dem Client ausgelöst werden, lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="4af18-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="4af18-196">`ConnectionSlow` Client Ereignis.</span><span class="sxs-lookup"><span data-stu-id="4af18-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="4af18-197">Wird ausgelöst, wenn ein vordefinierter Anteil des KeepAlive-Timeout Zeitraums seit dem Empfang der letzten Nachricht oder KeepAlive-Ping abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="4af18-198">Der standardmäßige KeepAlive-Timeout-Zeitraum ist 2/3 des KeepAlive-Timeouts.</span><span class="sxs-lookup"><span data-stu-id="4af18-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="4af18-199">Der KeepAlive-Timeout Wert beträgt 20 Sekunden, sodass die Warnung bei ungefähr 13 Sekunden auftritt.</span><span class="sxs-lookup"><span data-stu-id="4af18-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="4af18-200">Standardmäßig sendet der Server Keepalive-Pings alle 10 Sekunden, und der Client prüft ca. 2 Sekunden auf KeepAlive-Pings (ein Drittel der Differenz zwischen dem KeepAlive-Timeout Wert und dem KeepAlive-Timeout-Warn Wert).</span><span class="sxs-lookup"><span data-stu-id="4af18-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="4af18-201">Wenn die Transport-API eine Trennung erkennt, wird signalr möglicherweise über die Trennung informiert, bevor der Zeitraum für das KeepAlive-Timeout überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="4af18-202">In diesem Fall würde das Ereignis `ConnectionSlow` nicht ausgelöst, und signalr würde direkt zum `Reconnecting` Ereignis gehen.</span><span class="sxs-lookup"><span data-stu-id="4af18-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="4af18-203">`Reconnecting` Client Ereignis.</span><span class="sxs-lookup"><span data-stu-id="4af18-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="4af18-204">Wird ausgelöst, wenn (a) die Transport-API erkennt, dass die Verbindung unterbrochen wurde, oder (b) der KeepAlive-Timeout Zeitraum seit dem Empfang der letzten Nachricht oder KeepAlive-Ping verstrichen ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="4af18-205">Der signalr-Client Code versucht, erneut eine Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="4af18-206">Sie können dieses Ereignis behandeln, wenn die Anwendung eine Aktion ausführen soll, wenn eine Transport Verbindung unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="4af18-207">Der standardmäßige KeepAlive-Timeout Zeitraum beträgt derzeit 20 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="4af18-208">Wenn der Client Code versucht, eine Hub-Methode aufzurufen, während signalr sich im Modus für die erneute Verbindungs Herstellung befindet, versucht signalr, den Befehl zu senden.</span><span class="sxs-lookup"><span data-stu-id="4af18-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="4af18-209">In den meisten Fällen schlagen solche Versuche fehl, aber in einigen Fällen können Sie erfolgreich ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="4af18-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="4af18-210">Für die vom Server gesendeten Ereignisse, den dauerhaften Rahmen und lange Abruf Transporte verwendet signalr zwei Kommunikationskanäle: einen, den der Client zum Senden von Nachrichten verwendet, und einen, den der Client zum Empfangen von Nachrichten verwendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="4af18-211">Der für den Empfang verwendete Kanal ist das dauerhaft geöffnete, und das ist das, das geschlossen wird, wenn die physische Verbindung unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="4af18-212">Der zum Senden verwendete Kanal bleibt verfügbar. Wenn also die physische Konnektivität wieder hergestellt wird, kann ein Methodenaufrufe vom Client zum Server erfolgreich sein, bevor der Empfangskanal wieder hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="4af18-213">Der Rückgabewert wird erst empfangen, wenn signalr den Kanal erneut öffnet, der für den Empfang verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="4af18-214">`Reconnected` Client Ereignis.</span><span class="sxs-lookup"><span data-stu-id="4af18-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="4af18-215">Wird ausgelöst, wenn die Transport Verbindung wieder hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="4af18-216">Der `OnReconnected`-Ereignishandler im Hub wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4af18-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="4af18-217">`Closed` Client Ereignis (`disconnected`-Ereignis in JavaScript).</span><span class="sxs-lookup"><span data-stu-id="4af18-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="4af18-218">Wird ausgelöst, wenn das Trennungs Timeout abgelaufen ist, während der signalr-Client Code versucht, die Verbindung nach dem Verlust der Transport Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="4af18-219">Der Standardwert für das Trennen der Verbindung beträgt 30 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="4af18-220">(Dieses Ereignis wird auch ausgelöst, wenn die Verbindung beendet wird, da die `Stop`-Methode aufgerufen wird.)</span><span class="sxs-lookup"><span data-stu-id="4af18-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="4af18-221">Transport Verbindungsunterbrechungen, die nicht von der Transport-API erkannt werden und den Empfang von KeepAlive-Pings vom Server für einen längeren Zeitraum als das KeepAlive-Timeout nicht verzögern, bewirken möglicherweise nicht, dass Ereignisse der Verbindungs Lebensdauer ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="4af18-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="4af18-222">In einigen Netzwerkumgebungen werden Verbindungen im Leerlauf absichtlich geschlossen, und eine weitere Funktion der KeepAlive-Pakete besteht darin, dies zu verhindern, da diese Netzwerke wissen, dass eine signalr-Verbindung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="4af18-223">In Extremfällen ist die Standard Häufigkeit von KeepAlive-Pings möglicherweise nicht ausreichend, um geschlossene Verbindungen zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="4af18-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="4af18-224">In diesem Fall können Sie Keepalive-Pings so konfigurieren, dass Sie häufiger gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="4af18-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="4af18-225">Weitere Informationen finden Sie weiter unten in diesem Thema unter [Timeout-und KeepAlive-Einstellungen](#timeoutkeepalive) .</span><span class="sxs-lookup"><span data-stu-id="4af18-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="4af18-226">**Wichtig**: die hier beschriebene Abfolge von Ereignissen ist nicht sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="4af18-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="4af18-227">Mit signalr wird jeder Versuch unternommen, Verbindungs Lebensdauer-Ereignisse gemäß diesem Schema auf vorhersagbare Weise zu lösen. es gibt jedoch viele Variationen von Netzwerk Ereignissen und viele Möglichkeiten, wie die zugrunde liegenden Kommunikations Frameworks wie Transport-APIs diese verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="4af18-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="4af18-228">Beispielsweise wird das `Reconnected` Ereignis möglicherweise nicht ausgelöst, wenn der Client erneut eine Verbindung herstellt, oder der `OnConnected` Handler auf dem Server wird möglicherweise ausgeführt, wenn der Versuch, eine Verbindung herzustellen, nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="4af18-229">In diesem Thema werden nur die Auswirkungen beschrieben, die normalerweise in bestimmten typischen Fällen entstehen würden.</span><span class="sxs-lookup"><span data-stu-id="4af18-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="4af18-230">Szenarios zur Trennung von Clients</span><span class="sxs-lookup"><span data-stu-id="4af18-230">Client disconnection scenarios</span></span>

<span data-ttu-id="4af18-231">In einem Browser Client wird der signalr-Client Code, der eine signalr-Verbindung verwaltet, im JavaScript-Kontext einer Webseite ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4af18-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="4af18-232">Aus diesem Grund muss die signalr-Verbindung beendet werden, wenn Sie von einer Seite zu einer anderen navigieren, und das ist der Grund dafür, dass Sie mehrere Verbindungen mit mehreren Verbindungs-IDs haben, wenn Sie eine Verbindung über mehrere Browserfenster oder-Registerkarten herstellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="4af18-233">Wenn der Benutzer ein Browserfenster oder eine Registerkarte schließt oder zu einer neuen Seite navigiert oder die Seite aktualisiert, wird die signalr-Verbindung sofort beendet, da der signalr-Client Code dieses Browser Ereignis für Sie behandelt und die `Stop` Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="4af18-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="4af18-234">In diesen Szenarien oder auf einer beliebigen Client Plattform, wenn Ihre Anwendung die `Stop`-Methode aufruft, wird der `OnDisconnected`-Ereignishandler sofort auf dem Server ausgeführt, und der Client löst das `Closed`-Ereignis aus (das Ereignis wird in JavaScript als `disconnected` bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="4af18-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="4af18-235">Wenn eine Client Anwendung oder der Computer, auf dem Sie ausgeführt wird, abstürzen oder in den Standbymodus wechselt (z. b. wenn der Benutzer den Laptop schließt), wird der Server nicht informiert, was passiert ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="4af18-236">Wenn der Server weiß, kann der Verlust des Clients auf eine Verbindungsunterbrechung zurückzuführen sein, und der Client versucht möglicherweise, die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="4af18-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="4af18-237">Daher wartet der Server in diesen Szenarien darauf, dem Client die Möglichkeit zu geben, erneut eine Verbindung herzustellen, und `OnDisconnected` wird erst ausgeführt, wenn das Timeout für die Trennung abläuft (standardmäßig ca. 30 Sekunden).</span><span class="sxs-lookup"><span data-stu-id="4af18-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="4af18-238">Dieses Szenario wird im folgenden Diagramm veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4af18-238">The following diagram illustrates this scenario.</span></span>

![Client Computerfehler](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="4af18-240">Szenarios zur Server Trennung</span><span class="sxs-lookup"><span data-stu-id="4af18-240">Server disconnection scenarios</span></span>

<span data-ttu-id="4af18-241">Wenn ein Server offline geschaltet wird, wird er neu gestartet, schlägt fehl, die APP-Domäne wird wieder verwendet usw.--das Ergebnis könnte einer verlorenen Verbindung ähneln, oder die Transport-API und signalr wissen, dass der Server nicht mehr verfügbar ist, und signalr versucht möglicherweise, die Verbindung wiederherzustellen, ohne das `ConnectionSlow` Ereignis zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="4af18-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="4af18-242">Wenn der Client in den Modus zum erneuten Verbinden wechselt und der Server wieder hergestellt oder neu gestartet wird oder ein neuer Server vor Ablauf des Trennungs Timeouts online geschaltet wird, stellt der Client erneut eine Verbindung mit dem wiederhergestellten oder neuen Server her.</span><span class="sxs-lookup"><span data-stu-id="4af18-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="4af18-243">In diesem Fall wird die signalr-Verbindung auf dem Client fortgesetzt, und das `Reconnected`-Ereignis wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="4af18-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="4af18-244">Auf dem ersten Server wird `OnDisconnected` nie ausgeführt, und auf dem neuen Server wird `OnReconnected` ausgeführt, obwohl `OnConnected` zuvor nie für diesen Client auf diesem Server ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="4af18-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="4af18-245">(Der Effekt ist derselbe, wenn der Client nach einem Neustart oder der Wiederverwendung der APP-Domäne erneut eine Verbindung mit dem gleichen Server herstellt, denn wenn der Server neu gestartet wird, hat er keinen Speicher für vorherige Verbindungs Aktivitäten.) Im folgenden Diagramm wird davon ausgegangen, dass die Transport-API die verlorene Verbindung sofort erkennt, sodass das `ConnectionSlow`-Ereignis nicht ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Server Fehler und erneute Verbindung](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="4af18-247">Wenn ein Server innerhalb des Trennungs Timeouts nicht verfügbar wird, wird die signalr-Verbindung beendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="4af18-248">In diesem Szenario wird das `Closed` Ereignis (`disconnected` in JavaScript-Clients) auf dem Client ausgelöst, `OnDisconnected` jedoch nie auf dem Server aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="4af18-249">Im folgenden Diagramm wird davon ausgegangen, dass die Transport-API die verlorene Verbindung nicht erkennt, sodass Sie von der signalr KeepAlive-Funktionalität erkannt wird und das `ConnectionSlow`-Ereignis ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Server Fehler und-Timeout](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="4af18-251">Timeout-und KeepAlive-Einstellungen</span><span class="sxs-lookup"><span data-stu-id="4af18-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="4af18-252">Die Standardwerte für `ConnectionTimeout`, `DisconnectTimeout`und `KeepAlive` sind für die meisten Szenarien geeignet, können aber geändert werden, wenn Ihre Umgebung besondere Anforderungen hat.</span><span class="sxs-lookup"><span data-stu-id="4af18-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="4af18-253">Wenn in Ihrer Netzwerkumgebung beispielsweise Verbindungen geschlossen werden, die 5 Sekunden lang im Leerlauf sind, müssen Sie den KeepAlive-Wert möglicherweise verringern.</span><span class="sxs-lookup"><span data-stu-id="4af18-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="4af18-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="4af18-254">ConnectionTimeout</span></span>

<span data-ttu-id="4af18-255">Diese Einstellung gibt an, wie lange eine Transport Verbindung geöffnet bleiben und auf eine Antwort gewartet werden soll, bevor Sie geschlossen und eine neue Verbindung geöffnet wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="4af18-256">Der Standardwert ist 110 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="4af18-257">Diese Einstellung gilt nur, wenn die KeepAlive-Funktionalität deaktiviert ist. Dies gilt normalerweise nur für den langen Abruf Transport.</span><span class="sxs-lookup"><span data-stu-id="4af18-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="4af18-258">Das folgende Diagramm veranschaulicht die Auswirkung dieser Einstellung auf eine lange Abruf Transport Verbindung.</span><span class="sxs-lookup"><span data-stu-id="4af18-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Lange Abruf Transport Verbindung](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="4af18-260">"Disconnecttimeout"</span><span class="sxs-lookup"><span data-stu-id="4af18-260">DisconnectTimeout</span></span>

<span data-ttu-id="4af18-261">Diese Einstellung gibt die Zeitspanne an, die gewartet wird, nachdem eine Transport Verbindung unterbrochen wurde, bevor das `Disconnected` Ereignis erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="4af18-262">Der Standardwert ist 30 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-262">The default value is 30 seconds.</span></span> <span data-ttu-id="4af18-263">Wenn Sie `DisconnectTimeout`festlegen, wird `KeepAlive` automatisch auf 1/3 des `DisconnectTimeout` Werts festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4af18-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="4af18-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="4af18-264">KeepAlive</span></span>

<span data-ttu-id="4af18-265">Diese Einstellung gibt die Zeitspanne an, die gewartet werden soll, bevor ein KeepAlive-Paket über eine Verbindung im Leerlauf gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="4af18-266">Der Standardwert beträgt 10 Sekunden.</span><span class="sxs-lookup"><span data-stu-id="4af18-266">The default value is 10 seconds.</span></span> <span data-ttu-id="4af18-267">Dieser Wert darf nicht größer als 1/3 des `DisconnectTimeout` Werts sein.</span><span class="sxs-lookup"><span data-stu-id="4af18-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="4af18-268">Wenn Sie sowohl `DisconnectTimeout` als auch `KeepAlive`festlegen möchten, legen Sie `KeepAlive` nach `DisconnectTimeout`fest.</span><span class="sxs-lookup"><span data-stu-id="4af18-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="4af18-269">Andernfalls wird die `KeepAlive` Einstellung überschrieben, wenn `DisconnectTimeout` automatisch `KeepAlive` auf 1/3 des Timeout Werts festlegt.</span><span class="sxs-lookup"><span data-stu-id="4af18-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="4af18-270">Wenn Sie die KeepAlive-Funktion deaktivieren möchten, legen Sie `KeepAlive` auf NULL fest.</span><span class="sxs-lookup"><span data-stu-id="4af18-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="4af18-271">Die KeepAlive-Funktion wird für den langen Abruf Transport automatisch deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="4af18-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="4af18-272">Ändern der Timeout-und KeepAlive-Einstellungen</span><span class="sxs-lookup"><span data-stu-id="4af18-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="4af18-273">Um die Standardwerte für diese Einstellungen zu ändern, legen Sie diese in `Application_Start` in der Datei *Global. asax* fest, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="4af18-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="4af18-274">Die Werte, die im Beispielcode angezeigt werden, entsprechen den Standardwerten.</span><span class="sxs-lookup"><span data-stu-id="4af18-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="4af18-275">Benachrichtigen des Benutzers über Trennungen</span><span class="sxs-lookup"><span data-stu-id="4af18-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="4af18-276">In einigen Anwendungen können Sie dem Benutzer eine Meldung anzeigen, wenn Konnektivitätsprobleme vorliegen.</span><span class="sxs-lookup"><span data-stu-id="4af18-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="4af18-277">Sie haben mehrere Möglichkeiten, wie und wann dies zu tun ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="4af18-278">Die folgenden Codebeispiele gelten für einen JavaScript-Client, der den generierten Proxy verwendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="4af18-279">Behandeln Sie das `connectionSlow` Ereignis, um eine Meldung anzuzeigen, sobald signalr Verbindungsprobleme erkennt, bevor es in den erneuten Verbindungs Modus wechselt.</span><span class="sxs-lookup"><span data-stu-id="4af18-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="4af18-280">Behandeln Sie das `reconnecting`-Ereignis, um eine Meldung anzuzeigen, wenn signalr eine Trennung der Verbindung erkennt und den Modus für die erneute Verbindung wiederherstellt.</span><span class="sxs-lookup"><span data-stu-id="4af18-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="4af18-281">Behandeln Sie das `disconnected`-Ereignis, um eine Meldung anzuzeigen, wenn beim Versuch, die Verbindung wiederherzustellen, ein Timeout aufgetreten ist In diesem Szenario ist die einzige Möglichkeit, erneut eine Verbindung mit dem Server herzustellen, die signalr-Verbindung neu zu starten, indem Sie die `Start`-Methode aufrufen, mit der eine neue Verbindungs-ID erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="4af18-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="4af18-282">Im folgenden Codebeispiel wird mithilfe eines Flags sichergestellt, dass die Benachrichtigung nur nach einem Timeout der erneuten Verbindungs Herstellung ausgegeben wird, nicht nach einem normalen Ende der signalr-Verbindung, die durch den Aufruf der `Stop`-Methode verursacht wurde.</span><span class="sxs-lookup"><span data-stu-id="4af18-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="4af18-283">Fortlaufende Wiederherstellung der Verbindung</span><span class="sxs-lookup"><span data-stu-id="4af18-283">How to continuously reconnect</span></span>

<span data-ttu-id="4af18-284">In einigen Anwendungen möchten Sie möglicherweise automatisch eine Verbindung wiederherstellen, nachdem Sie verloren gegangen ist und der Versuch, eine Verbindung herzustellen, einen Timeout verursacht hat. Zu diesem Zweck können Sie die `Start`-Methode von Ihrem `Closed`-Ereignishandler (`disconnected`-Ereignishandler auf JavaScript-Clients) abrufen.</span><span class="sxs-lookup"><span data-stu-id="4af18-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="4af18-285">Möglicherweise möchten Sie eine gewisse Zeit warten, bevor Sie `Start` aufrufen, um dies zu vermeiden, wenn der Server oder die physische Verbindung nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="4af18-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="4af18-286">Das folgende Codebeispiel gilt für einen JavaScript-Client, der den generierten Proxy verwendet.</span><span class="sxs-lookup"><span data-stu-id="4af18-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="4af18-287">Ein potenzielles Problem, das bei mobilen Clients zu beachten ist, besteht darin, dass bei einem kontinuierlichen erneuten Verbindungsversuch, wenn der Server oder die physische Verbindung nicht verfügbar ist, eine unnötige Akku Ableitung verursachen</span><span class="sxs-lookup"><span data-stu-id="4af18-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="4af18-288">Trennen einer Verbindung zwischen einem Client und Servercode</span><span class="sxs-lookup"><span data-stu-id="4af18-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="4af18-289">Signalr Version 2 verfügt über keine integrierte Server-API zum Trennen der Verbindung von Clients.</span><span class="sxs-lookup"><span data-stu-id="4af18-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="4af18-290">Es gibt [Pläne, diese Funktionalität in Zukunft hinzuzufügen](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="4af18-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="4af18-291">In der aktuellen signalr-Version ist die einfachste Möglichkeit, einen Client vom Server zu trennen, eine Disconnect-Methode auf dem Client zu implementieren und diese Methode vom Server aus aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="4af18-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="4af18-292">Das folgende Codebeispiel zeigt eine Disconnect-Methode für einen JavaScript-Client unter Verwendung des generierten Proxys.</span><span class="sxs-lookup"><span data-stu-id="4af18-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="4af18-293">Sicherheit: weder diese Methode zum Trennen der Verbindung von Clients noch die vorgeschlagene integrierte API adressiert das Szenario von gehackten Clients, die bösartigen Code ausführen, da die Clients erneut eine Verbindung herstellen können, oder der Hacker Code die `stopClient` Methode entfernen oder ändern kann.</span><span class="sxs-lookup"><span data-stu-id="4af18-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="4af18-294">Der geeignete Ort zum Implementieren des Zustands behafteten Denial-of-Service (DOS)-Schutzes ist nicht im Framework oder auf der Serverebene, sondern in der Front-End-Infrastruktur.</span><span class="sxs-lookup"><span data-stu-id="4af18-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="4af18-295">Erkennen der Ursache für eine Verbindungs Trennung</span><span class="sxs-lookup"><span data-stu-id="4af18-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="4af18-296">Signalr 2,1 fügt dem Server eine Überladung hinzu `OnDisconnect` Ereignis, das angibt, ob der Client absichtlich getrennt wurde, anstatt ein Timeout festzustellen. Der `StopCalled`-Parameter ist true, wenn die Verbindung vom Client explizit geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="4af18-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="4af18-297">Wenn der Client in JavaScript aufgrund eines Server Fehlers die Verbindung getrennt hat, werden die Fehlerinformationen als `$.connection.hub.lastError`an den Client übermittelt.</span><span class="sxs-lookup"><span data-stu-id="4af18-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="4af18-298">**C#Servercode: `stopCalled`-Parameter**</span><span class="sxs-lookup"><span data-stu-id="4af18-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="4af18-299">**JavaScript-Client Code: Zugriff auf `lastError` im `disconnect`-Ereignis.**</span><span class="sxs-lookup"><span data-stu-id="4af18-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
