---
title: Purpose-Zeichenfolgen in ASP.NET Core
author: rick-anderson
description: Erfahren Sie, wie Purpose-Zeichenfolgen in ASP.NET Core Datenschutz-APIs verwendet werden.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 4c85423f8de7e4b784ae1bb304a884541df251b6
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/01/2019
ms.locfileid: "57051287"
---
# <a name="purpose-strings-in-aspnet-core"></a><span data-ttu-id="aa5e4-103">Purpose-Zeichenfolgen in ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="aa5e4-103">Purpose strings in ASP.NET Core</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="aa5e4-104">Komponenten, die nutzen `IDataProtectionProvider` muss einen eindeutigen bestehen *Zwecke* Parameter, um die `CreateProtector` Methode.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-104">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="aa5e4-105">Im Sinne *Parameter* ist dieses System zum Schutz von Daten, die Sicherheit Isolation zwischen kryptografischen Consumern, auch wenn die Stamm-kryptografischen Schlüssel identisch sind.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-105">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="aa5e4-106">Wenn ein Consumer einen Zweck angegeben ist, wird die Zweck-Zeichenfolge zusammen mit der Stamm-Kryptografieschlüssel verwendet, um kryptografische Unterschlüssel eindeutig, kann der Kunde abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-106">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="aa5e4-107">Dadurch wird den Consumer vor allen anderen kryptografischen Consumern in der Anwendung isoliert: keine andere Komponente der Nutzlasten lesen kann, und keine andere Komponente-Nutzlasten gelesen.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-107">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="aa5e4-108">Diese Isolierung wird auch nicht realisierbare ganze Kategorien der Angriff auf die Komponente gerendert.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-108">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Beispiel für ein allgemeines Diagramm](purpose-strings/_static/purposes.png)

<span data-ttu-id="aa5e4-110">In der Abbildung oben `IDataProtector` Instanzen A und B **kann nicht** gegenseitig-Nutzlasten für Lesen, nur ihre eigenen.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-110">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="aa5e4-111">Die Zweck Zeichenfolge nicht geheim sein.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-111">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="aa5e4-112">Es sollte einfach insofern eindeutig sein, dass keine andere kaum Komponente immer die gleiche Zeichenfolge für den Zweck bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-112">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="aa5e4-113">Unter Verwendung des Namespace und Typ der Komponente, die die Datenschutz-APIs nutzen, ist eine gute Faustregel, wie in der Praxis, die diese Informationen nicht in Konflikt steht.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-113">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="aa5e4-114">Eine Contoso autorisierten-Komponente, die für die minting Bearer-Tokens zuständig ist, kann Contoso.Security.BearerToken als dessen Zweck Zeichenfolge verwenden.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-114">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="aa5e4-115">Oder – noch besser – sie können Contoso.Security.BearerToken.v1 als dessen Zweck-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-115">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="aa5e4-116">Ermöglicht das Anfügen der Versionsnummer einer zukünftigen Version Contoso.Security.BearerToken.v2 als ihren Zweck zu verwenden, und die verschiedenen Versionen wäre vollständig voneinander isoliert, so weit Nutzlasten wechseln.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-116">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="aa5e4-117">Seit den Zwecke-Parameter, um `CreateProtector` ist ein Zeichenfolgenarray der oben genannten konnte haben stattdessen angegeben wurde als `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-117">Since the purposes parameter to `CreateProtector` is a string array, the above could've been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="aa5e4-118">Dies ermöglicht das Erstellen einer Hierarchie von Zwecken und eröffnet die Möglichkeit der mehrinstanzenfähigkeit-Szenarien mit dem System zum Schutz von Daten.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-118">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="aa5e4-119">Komponenten sollten nicht nicht vertrauenswürdiger Benutzereingaben als einzige Quelle der Eingabe für die Kette zu ausgewählt werden können.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-119">Components shouldn't allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="aa5e4-120">Betrachten Sie beispielsweise eine Komponente Contoso.Messaging.SecureMessage, die für das Speichern von sicheren Nachrichten zuständig ist.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-120">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="aa5e4-121">Würde die sichere Messagingkomponente Aufrufen `CreateProtector([ username ])`, und klicken Sie dann ein böswilliger Benutzer ein Konto mit dem Benutzernamen "Contoso.Security.BearerToken" Fehler beim Abrufen der Komponente aufrufen, erstellen kann `CreateProtector([ "Contoso.Security.BearerToken" ])`, so unbeabsichtigt verursacht das secure messaging System Mint-Nutzlasten, die als Authentifizierungstoken wahrgenommen werden kann.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-121">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="aa5e4-122">Es wäre eine bessere Zwecke-Kette für die messaging-Komponente `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, die richtigen Isolation bietet.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-122">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="aa5e4-123">Die Isolierung durch und das Verhalten der `IDataProtectionProvider`, `IDataProtector`, und Zwecke lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="aa5e4-123">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="aa5e4-124">Für eine angegebenen `IDataProtectionProvider` -Objekt, das `CreateProtector` Methode erstellt ein `IDataProtector` Objekt eindeutig gebunden werden, sowohl die `IDataProtectionProvider` Objekt, das erstellt hat und der Zweck-Parameter, der an die Methode übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-124">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="aa5e4-125">Der Zweck-Parameter darf nicht null sein.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-125">The purpose parameter must not be null.</span></span> <span data-ttu-id="aa5e4-126">(Wenn Zwecke als Bytearray angegeben ist, bedeutet dies, dass das Array nicht der Länge Null sein darf und alle Elemente des Arrays müssen ungleich Null sein.) Ein leere Zeichenfolge Zweck ist technisch zulässig, wird jedoch abgeraten.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-126">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="aa5e4-127">Argumente für zwei Zwecke sind gleichwertig, nur, wenn sie die gleichen Zeichenfolgen (einen ordinalen Vergleich mit) in der gleichen Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-127">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="aa5e4-128">Ein Zweck-Argument ist das entsprechende begründungsarray von einem Element entspricht.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-128">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="aa5e4-129">Zwei `IDataProtector` Objekte sind äquivalent, wenn sie über entsprechende erstellt werden `IDataProtectionProvider` Objekte mit entsprechenden Zwecke-Parameter.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-129">Two `IDataProtector` objects are equivalent if and only if they're created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="aa5e4-130">Für einen bestimmten `IDataProtector` -Objekt, das einen Aufruf von `Unprotect(protectedData)` zurück, wird der ursprüngliche `unprotectedData` nur, wenn `protectedData := Protect(unprotectedData)` ein entsprechendes `IDataProtector` Objekt.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-130">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="aa5e4-131">Wir sind nicht den Fall in Betracht ziehen, in denen eine Komponente absichtlich eine Zeichenfolge Zweck wählt die einen Konflikt mit einer anderen Komponente bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-131">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="aa5e4-132">Eine solche Komponente wird im Wesentlichen böswillige berücksichtigt werden, und dieses System ist nicht vorgesehen, Sicherheitsgarantien bereitstellen, die bösartiger Code innerhalb des Arbeitsprozesses bereits ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="aa5e4-132">Such a component would essentially be considered malicious, and this system isn't intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
