---
title: Unterschlüsselableitung und authentifizierte Verschlüsselung in ASP.NET Core
author: rick-anderson
description: Erfahren Sie Details zur Implementierung des Datenschutzes für ASP.NET Core Ableitung Unterschlüssel und authentifizierte Verschlüsselung.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/01/2019
ms.locfileid: "57047247"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="b9e8c-103">Unterschlüsselableitung und authentifizierte Verschlüsselung in ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="b9e8c-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="b9e8c-104">Die meisten Schlüssel in den Schlüsselbund enthält eine Form der Entropie und verfügen über algorithmische Informationen, die mit dem Hinweis "CBC-Modus-Verschlüsselung + HMAC-Überprüfung" oder "GCM-Verschlüsselung und Überprüfung".</span><span class="sxs-lookup"><span data-stu-id="b9e8c-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="b9e8c-105">Klicken Sie in diesen Fällen wir verweisen auf die eingebettete Entropie, als das Schlüsselmaterial (oder KM) für diesen Schlüssel, und wir führen eine schlüsselableitung-Funktion, um die Schlüssel abgeleitet werden, die für die tatsächlichen kryptografischen Vorgänge verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="b9e8c-106">Schlüssel sind abstrakt, und eine benutzerdefinierte Implementierung Verhalten sich ggf. nicht wie unten gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="b9e8c-107">Wenn der Schlüssel eine eigene Implementierung des bietet `IAuthenticatedEncryptor` statt eines integrierten Factorys verwenden, der in diesem Abschnitt beschriebenen Mechanismus nicht mehr angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="b9e8c-108">Zusätzliche authentifizierte Daten "und" unterschlüsselableitung</span><span class="sxs-lookup"><span data-stu-id="b9e8c-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="b9e8c-109">Die `IAuthenticatedEncryptor` -Schnittstelle dient als die Kernschnittstelle, die für alle authentifizierten Verschlüsselungsvorgänge.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="b9e8c-110">Die `Encrypt` Methode nimmt zwei Puffer: nur-Text und AdditionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="b9e8c-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="b9e8c-111">Der Datenfluss der nur-Text-Inhalt unverändert, den Aufruf von `IDataProtector.Protect`, aber die AAD wird vom System generiert und besteht aus drei Komponenten:</span><span class="sxs-lookup"><span data-stu-id="b9e8c-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="b9e8c-112">Der 32-Bit-Magic-Header 09 F0 C9 F0, die diese Version von System zum Schutz von Daten identifiziert.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="b9e8c-113">Die 128-Bit-Schlüssel-ID.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="b9e8c-114">Eine Zeichenfolge variabler Länge aus der Kette von Zweck, die erstellt formatiert die `IDataProtector` , diesen Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="b9e8c-115">Da die AAD für das Tupel aller drei Komponenten eindeutig ist, können wir es KM neue Schlüssel abgeleitet, anstatt KM selbst in allen unseren kryptografischen Vorgänge verwenden.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="b9e8c-116">Für jeden Aufruf von `IAuthenticatedEncryptor.Encrypt`, der folgende Prozess für die schlüsselableitung findet:</span><span class="sxs-lookup"><span data-stu-id="b9e8c-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="b9e8c-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="b9e8c-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="b9e8c-118">Hier rufen wir die NIST SP800-108 KDF in der Counter-Modus (finden Sie unter [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), SEC 5.1) mit den folgenden Parametern:</span><span class="sxs-lookup"><span data-stu-id="b9e8c-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="b9e8c-119">Ableiten des Schlüssels Schlüssel (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="b9e8c-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="b9e8c-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="b9e8c-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="b9e8c-121">Bezeichnung = AdditionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="b9e8c-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="b9e8c-122">context = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="b9e8c-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="b9e8c-123">Der Kontextheader mit variabler Länge ist, und es dient im Wesentlichen als ein Fingerabdruck der Algorithmen für die wir K_E und K_H ableiten.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="b9e8c-124">Der Schlüssel-Modifizierer ist eine 128-Bit-Zeichenfolge, die nach dem Zufallsprinzip generiert für jeden Aufruf von `Encrypt` und dient, um sicherzustellen, dass mit einer Überlastung der Wahrscheinlichkeit, dass KE und KH für diesen spezifischen Verschlüsselungsvorgang eindeutig sind, auch wenn alle anderen Eingaben an die KDF konstant ist.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="b9e8c-125">Für die Verschlüsselung CBC-Modus und HMAC-Überprüfungsvorgänge | K_E | die Länge des Schlüssels Verschlüsselung symmetrischer Blöcke und | K_H | ist die Digest-Größe, die HMAC-Routine.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="b9e8c-126">Für die Verschlüsselung von GCM und Überprüfungsvorgänge, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="b9e8c-127">CBC-Modus-Verschlüsselung + HMAC-Überprüfung</span><span class="sxs-lookup"><span data-stu-id="b9e8c-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="b9e8c-128">Nach K_E über die oben genannten-Mechanismus generiert wird, werden wir generiert einen zufälligen Initialisierungsvektor und führen Sie den Verschlüsselungsalgorithmus symmetrischer Blöcke um nur-Text zu verschlüsseln.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="b9e8c-129">Der Initialisierungsvektor und Chiffretext werden klicken Sie dann über die HMAC-Routine, die initialisiert werden, mit dem Schlüssel K_H zum Erzeugen von Mac ausgeführt</span><span class="sxs-lookup"><span data-stu-id="b9e8c-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="b9e8c-130">Dieser Prozess und der Rückgabewert wird grafisch im folgenden dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-130">This process and the return value is represented graphically below.</span></span>

![CBC-Modus-Prozess und Rückgabetypen](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="b9e8c-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span><span class="sxs-lookup"><span data-stu-id="b9e8c-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="b9e8c-133">Die `IDataProtector.Protect` Implementierung wird [stellen Sie den Magic-Header und die Schlüssel-Id](xref:security/data-protection/implementation/authenticated-encryption-details) Ausgabe vor der Rückgabe an den Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="b9e8c-134">Da das Magic-Header und -Schlüssel-Id implizit Teil [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), da die Schlüsselmodifizierers als Eingabe für die KDF eingezogen wird, bedeutet, dass jedes einzelnes Byte die letzte zurückgegebene Nutzlast durch Mac authentifiziert wird</span><span class="sxs-lookup"><span data-stu-id="b9e8c-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="b9e8c-135">Galois/Counter-Modus-Verschlüsselung und Überprüfung</span><span class="sxs-lookup"><span data-stu-id="b9e8c-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="b9e8c-136">Sobald K_E über die oben genannten-Mechanismus generiert wird, werden wir generiert eine zufällige 96-Bit-Nonce und führen Sie den Verschlüsselungsalgorithmus symmetrischer Blöcke zu verschlüsseln den nur-Text und die 128-Bit-authentifizierungstag erzeugt hat.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM-Modus-Prozess und Rückgabetypen](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="b9e8c-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span><span class="sxs-lookup"><span data-stu-id="b9e8c-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="b9e8c-139">Obwohl GCM nativ das Konzept von AAD unterstützt, sind wir immer noch AAD nur für die ursprüngliche KDF, eingezogen um GCM für ihren AAD-Parameter eine leere Zeichenfolge übergeben.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="b9e8c-140">Der Grund dafür ist zwei Stufen.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-140">The reason for this is two-fold.</span></span> <span data-ttu-id="b9e8c-141">Zuerst [zur Unterstützung von Agilität](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) nie K_M direkt als Verschlüsselungsschlüssel verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="b9e8c-142">Darüber hinaus erzwingt GCM sehr strenge Eindeutigkeit Anforderungen in Bezug auf ihre Eingaben.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="b9e8c-143">Wahrscheinlichkeit, dass die Verschlüsselungsroutine von GCM jemals aufgerufene für zwei oder mehr unterschiedliche legt fest, der Eingabedaten mit dem gleichen (Schlüssel, Nonce) Paar darf nicht mehr als 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="b9e8c-144">Wenn wir K_E korrigieren wir nicht mehr als 2 möglich ^ 32 Verschlüsselungsvorgänge, bevor wir führen afoul der 2 of ^-32 zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="b9e8c-145">Dies mag wie eine sehr große Anzahl von Vorgängen kann, jedoch ein Webserver mit hohem Datenverkehr über 4 Milliarden Anfragen in reine Tage, innerhalb der normale Lebensdauer für diese Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="b9e8c-146">Der 2 konform bleiben ^-32 Wahrscheinlichkeit Grenzwert, wir weiterhin mit einem 128-Bit-Modifizierertaste und ein 96-Bit-Nonce, die die Anzahl der verwendbaren Vorgänge für alle angegebenen K_M radikal erweitert.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="b9e8c-147">Aus Gründen der Einfachheit des Entwurfs teilen wir der Pfad für den KDF zwischen CBC und GCM-Vorgängen, und da AAD bereits in die KDF gilt es nicht erforderlich, die an die Routine GCM weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="b9e8c-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
